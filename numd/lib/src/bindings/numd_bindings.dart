// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for `src/numd.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class NumdBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NumdBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NumdBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<ffi.Void> create_xarray(int ndim, ffi.Pointer<ffi.Int64> shape, double fill){
    return _create_xarray(ndim, shape, fill);
  }

  late final _create_xarrayPtr = _lookup< ffi.NativeFunction< ffi.Pointer<ffi.Void> Function(ffi.Int, ffi.Pointer<ffi.Int64>, ffi.Double)>>('create_xarray');
  late final _create_xarray = _create_xarrayPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, ffi.Pointer<ffi.Int64>, double)>();

  void delete_xarray(ffi.Pointer<ffi.Void> ptr) {
    return _delete_xarray(ptr);
  }

  late final delete_xarrayPtr =_lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>('delete_xarray');
  late final _delete_xarray = delete_xarrayPtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  int get_ndim(ffi.Pointer<ffi.Void> array,) {
    return _get_ndim(array);
  }

  late final _get_ndimPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>('get_ndim');
  late final _get_ndim = _get_ndimPtr.asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  int get_size(ffi.Pointer<ffi.Void> array,) {
    return _get_size(array,);
  }

  late final _get_sizePtr =_lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>('get_size');
  late final _get_size = _get_sizePtr.asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  void get_shape(ffi.Pointer<ffi.Void> array, ffi.Pointer<ffi.Int64> shape, ) {
    return _get_shape(array,shape);
  }

  late final _get_shapePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int64>)>>('get_shape');
  late final _get_shape = _get_shapePtr.asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int64>)>();

  void reshape(ffi.Pointer<ffi.Void> array, ffi.Pointer<ffi.Int64> shape, int ndim){
    return _reshape(array, shape, ndim);
  }

  late final _reshapePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>,ffi.Pointer<ffi.Int64>, ffi.Int)>>('reshape');
  late final _reshape = _reshapePtr.asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int64>, int)>();

  ffi.Pointer<ffi.Void> slice_array(ffi.Pointer<ffi.Void> array, ffi.Pointer<slice> slices, int n_slices,) {
    return _slice_array(array, slices, n_slices,);
  }

  late final _slice_arrayPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,ffi.Pointer<slice>, ffi.Int)>>('slice_array');
  late final _slice_array = _slice_arrayPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<slice>, int)>();

  void assign_array_to_slice(ffi.Pointer<ffi.Void> array, ffi.Pointer<ffi.Void> other_array, ffi.Pointer<slice> slices, int n_slices,) {
    return _assign_array_to_slice(array, other_array, slices, n_slices);
  }

  late final _assign_array_to_slicePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<slice>, ffi.Int)>>('assign_array_to_slice');
  late final _assign_array_to_slice = _assign_array_to_slicePtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<slice>, int)>();

  void assign_double_to_slice(
    ffi.Pointer<ffi.Void> array,
    double value,
    ffi.Pointer<slice> slices,
    int n_slices,
  ) {
    return _assign_double_to_slice(
      array,
      value,
      slices,
      n_slices,
    );
  }

  late final _assign_double_to_slicePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Double,
              ffi.Pointer<slice>, ffi.Int)>>('assign_double_to_slice');
  late final _assign_double_to_slice = _assign_double_to_slicePtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, double, ffi.Pointer<slice>, int)>();

  ffi.Pointer<ffi.Void> transpose(ffi.Pointer<ffi.Void> array, ) {
    return _transpose( array,);
  }

  late final _transposePtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('transpose');
  late final _transpose = _transposePtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> swapaxes(ffi.Pointer<ffi.Void> array, int axis1, int axis2) {
    return _swapaxes( array, axis1, axis2);
  }

  late final _swapaxesPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Int64, ffi.Int64)>>('swapaxes');
  late final _swapaxes = _swapaxesPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();


  ffi.Pointer<ffi.Void> flip(ffi.Pointer<ffi.Void> array, int axis) {
    return _flip( array, axis);
  }

  late final _flipPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>('flip');
  late final _flip = _flipPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> add_arrays(
    ffi.Pointer<ffi.Void> array_1,
    ffi.Pointer<ffi.Void> array_2,
  ) {
    return _add_arrays(
      array_1,
      array_2,
    );
  }

  late final _add_arraysPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>('add_arrays');
  late final _add_arrays = _add_arraysPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> add_double(
    ffi.Pointer<ffi.Void> array,
    double value,
  ) {
    return _add_double(
      array,
      value,
    );
  }

  late final _add_doublePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Double)>>('add_double');
  late final _add_double = _add_doublePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, double)>();

  ffi.Pointer<ffi.Void> substract_arrays(
    ffi.Pointer<ffi.Void> array_1,
    ffi.Pointer<ffi.Void> array_2,
  ) {
    return _substract_arrays(
      array_1,
      array_2,
    );
  }

  late final _substract_arraysPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>>('substract_arrays');
  late final _substract_arrays = _substract_arraysPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> substract_double(
    ffi.Pointer<ffi.Void> array,
    double value,
  ) {
    return _substract_double(
      array,
      value,
    );
  }

  late final _substract_doublePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Double)>>('substract_double');
  late final _substract_double = _substract_doublePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, double)>();

  ffi.Pointer<ffi.Void> multiply_arrays(
    ffi.Pointer<ffi.Void> array_1,
    ffi.Pointer<ffi.Void> array_2,
  ) {
    return _multiply_arrays(
      array_1,
      array_2,
    );
  }

  late final _multiply_arraysPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>>('multiply_arrays');
  late final _multiply_arrays = _multiply_arraysPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> multiply_double(
    ffi.Pointer<ffi.Void> array,
    double value,
  ) {
    return _multiply_double(
      array,
      value,
    );
  }

  late final _multiply_doublePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Double)>>('multiply_double');
  late final _multiply_double = _multiply_doublePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, double)>();

  ffi.Pointer<ffi.Void> divide_arrays(
    ffi.Pointer<ffi.Void> array_1,
    ffi.Pointer<ffi.Void> array_2,
  ) {
    return _divide_arrays(
      array_1,
      array_2,
    );
  }

  late final _divide_arraysPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>('divide_arrays');
  late final _divide_arrays = _divide_arraysPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> divide_double(
    ffi.Pointer<ffi.Void> array,
    double value,
  ) {
    return _divide_double(
      array,
      value,
    );
  }

  late final _divide_doublePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Double)>>('divide_double');
  late final _divide_double = _divide_doublePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, double)>();

  void assign_flat(
    ffi.Pointer<ffi.Void> ptr,
    int idx,
    double value,
  ) {
    return _assign_flat(
      ptr,
      idx,
      value,
    );
  }

  late final _assign_flatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Double)>>('assign_flat');
  late final _assign_flat = _assign_flatPtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, double)>();

  double return_flat(
    ffi.Pointer<ffi.Void> ptr,
    int idx,
  ) {
    return _return_flat(
      ptr,
      idx,
    );
  }

  late final _return_flatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Void>, ffi.Int)>>('return_flat');
  late final _return_flat =
      _return_flatPtr.asFunction<double Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> mean(
    ffi.Pointer<ffi.Void> array,
    ffi.Pointer<ffi.Int64> axis,
    int n_axis,
  ) {
    return _mean(
      array,
      axis,
      n_axis,
    );
  }

  late final _meanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int64>, ffi.Int)>>('mean');
  late final _mean = _meanPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int64>, int)>();

  ffi.Pointer<ffi.Void> min(
    ffi.Pointer<ffi.Void> array,
    ffi.Pointer<ffi.Int64> axis,
    int n_axis,
  ) {
    return _min(
      array,
      axis,
      n_axis,
    );
  }

  late final _minPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int64>, ffi.Int)>>('min');
  late final _min = _minPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int64>, int)>();

  ffi.Pointer<ffi.Void> max(
    ffi.Pointer<ffi.Void> array,
    ffi.Pointer<ffi.Int64> axis,
    int n_axis,
  ) {
    return _max(
      array,
      axis,
      n_axis,
    );
  }

  late final _maxPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int64>, ffi.Int)>>('max');
  late final _max = _maxPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int64>, int)>();

  ffi.Pointer<ffi.Void> nanmean( ffi.Pointer<ffi.Void> array, 
                                 ffi.Pointer<ffi.Int64> axis,
                                 int n_axis,) {
    return _nanmean(array, axis, n_axis);
  }

  late final _nanmeanPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void>
          Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int64>, ffi.Int)>>('nanmean');
  late final _nanmean = _nanmeanPtr.asFunction<ffi.Pointer<ffi.Void>
          Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int64>, int)>();

  
  ffi.Pointer<ffi.Void> nanmin(
    ffi.Pointer<ffi.Void> array,
    ffi.Pointer<ffi.Int64> axis,
    int n_axis,
  ) {
    return _nanmin(
      array,
      axis,
      n_axis,
    );
  }

  late final _nanminPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Int64>, ffi.Int)>>('nanmin');
  late final _nanmin = _nanminPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int64>, int)>();

  ffi.Pointer<ffi.Void> nanmax(
    ffi.Pointer<ffi.Void> array,
    ffi.Pointer<ffi.Int64> axis,
    int n_axis,
  ) {
    return _nanmax(
      array,
      axis,
      n_axis,
    );
  }

  late final _nanmaxPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Int64>, ffi.Int)>>('nanmax');
  late final _nanmax = _nanmaxPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int64>, int)>();

  ffi.Pointer<ffi.Void> normalize(
    ffi.Pointer<ffi.Void> array,
  ) {
    return _normalize(
      array,
    );
  }

  late final _normalizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('normalize');
  late final _normalize = _normalizePtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> rfft(
    ffi.Pointer<ffi.Void> array,
  ) {
    return _rfft(
      array,
    );
  }

  late final _rfftPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('rfft');
  late final _rfft = _rfftPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> rfft2(
    ffi.Pointer<ffi.Void> array,
  ) {
    return _rfft2(
      array,
    );
  }

  late final _rfft2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('rfft2');
  late final _rfft2 = _rfft2Ptr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> rfftfreq(
    int n,
    double d,
  ) {
    return _rfftfreq(
      n,
      d,
    );
  }

  late final _rfftfreqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Int64, ffi.Double)>>('rfftfreq');
  late final _rfftfreq =
      _rfftfreqPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, double)>();

  ffi.Pointer<ffi.Void> histogram_bin_edges(ffi.Pointer<ffi.Void> data, int nbins) {
    return _histogram_bin_edges( data, nbins);
  }

  late final _histogram_bin_edgesPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Int)>>('histogram_bin_edges');
  late final _histogram_bin_edges = _histogram_bin_edgesPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> histogram_count(ffi.Pointer<ffi.Void> data, ffi.Pointer<ffi.Void> bin_edges) {
    return _histogram_count( data, bin_edges);
  }

  late final _histogram_countPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>('histogram_count');
  late final _histogram_count = _histogram_countPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

    ffi.Pointer<ffi.Void> histogram_count_lin_bins(ffi.Pointer<ffi.Void> data, double min, double max, int nbins) {
    return _histogram_count_lin_bins(data, min, max, nbins);
  }

  late final _histogram_count_lin_binsPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Double, ffi.Double, ffi.Int)>>('histogram_count_lin_bins');
  late final _histogram_count_lin_bins = _histogram_count_lin_binsPtr.asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, double, double, int)>();

  void print_array(ffi.Pointer<ffi.Void> array,) {
    return _print_array(
      array,
    );
  }

  late final _print_arrayPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'print_array');
  late final _print_array =
      _print_arrayPtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
}

final class slice extends ffi.Struct {
  @ffi.Int64()
  external int start;

  @ffi.Int64()
  external int stop;

  @ffi.Int64()
  external int step;

  @ffi.Bool()
  external bool singleValue;
}

final class histogram_pointers extends ffi.Struct {
  external ffi.Pointer<ffi.Void> count;

  external ffi.Pointer<ffi.Void> bin_edges;
}
