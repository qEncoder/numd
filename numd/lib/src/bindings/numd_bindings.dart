// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for `src/numd.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class NumdBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NumdBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NumdBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<ffi.Void> create_xarray(
    int ndim,
    ffi.Pointer<ffi.Int64> shape,
    double fill,
  ) {
    return _create_xarray(
      ndim,
      shape,
      fill,
    );
  }

  late final _create_xarrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Int, ffi.Pointer<ffi.Int64>, ffi.Double)>>('create_xarray');
  late final _create_xarray = _create_xarrayPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(int, ffi.Pointer<ffi.Int64>, double)>();

  void delete_xarray(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _delete_xarray(
      ptr,
    );
  }

  late final delete_xarrayPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'delete_xarray');
  late final _delete_xarray =
      delete_xarrayPtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  int get_ndim(
    ffi.Pointer<ffi.Void> array,
  ) {
    return _get_ndim(
      array,
    );
  }

  late final _get_ndimPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>(
          'get_ndim');
  late final _get_ndim =
      _get_ndimPtr.asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  int get_size(
    ffi.Pointer<ffi.Void> array,
  ) {
    return _get_size(
      array,
    );
  }

  late final _get_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>(
          'get_size');
  late final _get_size =
      _get_sizePtr.asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  void get_shape(
    ffi.Pointer<ffi.Void> array,
    ffi.Pointer<ffi.Int64> shape,
  ) {
    return _get_shape(
      array,
      shape,
    );
  }

  late final _get_shapePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int64>)>>('get_shape');
  late final _get_shape = _get_shapePtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int64>)>();

  ffi.Pointer<ffi.Void> slice_array(
    ffi.Pointer<ffi.Void> array,
    ffi.Pointer<slice> slices,
    int n_slices,
  ) {
    return _slice_array(
      array,
      slices,
      n_slices,
    );
  }

  late final _slice_arrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<slice>, ffi.Int)>>('slice_array');
  late final _slice_array = _slice_arrayPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<slice>, int)>();

  void assign_array_to_slice(
    ffi.Pointer<ffi.Void> array,
    ffi.Pointer<ffi.Void> other_array,
    ffi.Pointer<slice> slices,
    int n_slices,
  ) {
    return _assign_array_to_slice(
      array,
      other_array,
      slices,
      n_slices,
    );
  }

  late final _assign_array_to_slicePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<slice>, ffi.Int)>>('assign_array_to_slice');
  late final _assign_array_to_slice = _assign_array_to_slicePtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<slice>, int)>();

  void assign_double_to_slice(
    ffi.Pointer<ffi.Void> array,
    double value,
    ffi.Pointer<slice> slices,
    int n_slices,
  ) {
    return _assign_double_to_slice(
      array,
      value,
      slices,
      n_slices,
    );
  }

  late final _assign_double_to_slicePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Double,
              ffi.Pointer<slice>, ffi.Int)>>('assign_double_to_slice');
  late final _assign_double_to_slice = _assign_double_to_slicePtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, double, ffi.Pointer<slice>, int)>();

  ffi.Pointer<ffi.Void> transpose(
    ffi.Pointer<ffi.Void> array,
  ) {
    return _transpose(
      array,
    );
  }

  late final _transposePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('transpose');
  late final _transpose = _transposePtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> add_arrays(
    ffi.Pointer<ffi.Void> array_1,
    ffi.Pointer<ffi.Void> array_2,
  ) {
    return _add_arrays(
      array_1,
      array_2,
    );
  }

  late final _add_arraysPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>('add_arrays');
  late final _add_arrays = _add_arraysPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> add_double(
    ffi.Pointer<ffi.Void> array,
    double value,
  ) {
    return _add_double(
      array,
      value,
    );
  }

  late final _add_doublePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Double)>>('add_double');
  late final _add_double = _add_doublePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, double)>();

  ffi.Pointer<ffi.Void> substract_arrays(
    ffi.Pointer<ffi.Void> array_1,
    ffi.Pointer<ffi.Void> array_2,
  ) {
    return _substract_arrays(
      array_1,
      array_2,
    );
  }

  late final _substract_arraysPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>>('substract_arrays');
  late final _substract_arrays = _substract_arraysPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> substract_double(
    ffi.Pointer<ffi.Void> array,
    double value,
  ) {
    return _substract_double(
      array,
      value,
    );
  }

  late final _substract_doublePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Double)>>('substract_double');
  late final _substract_double = _substract_doublePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, double)>();

  ffi.Pointer<ffi.Void> multiply_arrays(
    ffi.Pointer<ffi.Void> array_1,
    ffi.Pointer<ffi.Void> array_2,
  ) {
    return _multiply_arrays(
      array_1,
      array_2,
    );
  }

  late final _multiply_arraysPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>>('multiply_arrays');
  late final _multiply_arrays = _multiply_arraysPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> multiply_double(
    ffi.Pointer<ffi.Void> array,
    double value,
  ) {
    return _multiply_double(
      array,
      value,
    );
  }

  late final _multiply_doublePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Double)>>('multiply_double');
  late final _multiply_double = _multiply_doublePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, double)>();

  ffi.Pointer<ffi.Void> divide_arrays(
    ffi.Pointer<ffi.Void> array_1,
    ffi.Pointer<ffi.Void> array_2,
  ) {
    return _divide_arrays(
      array_1,
      array_2,
    );
  }

  late final _divide_arraysPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>('divide_arrays');
  late final _divide_arrays = _divide_arraysPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> divide_double(
    ffi.Pointer<ffi.Void> array,
    double value,
  ) {
    return _divide_double(
      array,
      value,
    );
  }

  late final _divide_doublePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Double)>>('divide_double');
  late final _divide_double = _divide_doublePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, double)>();

  void assign_flat(
    ffi.Pointer<ffi.Void> ptr,
    int idx,
    double value,
  ) {
    return _assign_flat(
      ptr,
      idx,
      value,
    );
  }

  late final _assign_flatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Double)>>('assign_flat');
  late final _assign_flat = _assign_flatPtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, double)>();

  double return_flat(
    ffi.Pointer<ffi.Void> ptr,
    int idx,
  ) {
    return _return_flat(
      ptr,
      idx,
    );
  }

  late final _return_flatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Void>, ffi.Int)>>('return_flat');
  late final _return_flat =
      _return_flatPtr.asFunction<double Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> mean(
    ffi.Pointer<ffi.Void> array,
    ffi.Pointer<ffi.Int64> axis,
    int n_axis,
  ) {
    return _mean(
      array,
      axis,
      n_axis,
    );
  }

  late final _meanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int64>, ffi.Int)>>('mean');
  late final _mean = _meanPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int64>, int)>();

  ffi.Pointer<ffi.Void> min(
    ffi.Pointer<ffi.Void> array,
    ffi.Pointer<ffi.Int64> axis,
    int n_axis,
  ) {
    return _min(
      array,
      axis,
      n_axis,
    );
  }

  late final _minPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int64>, ffi.Int)>>('min');
  late final _min = _minPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int64>, int)>();

  ffi.Pointer<ffi.Void> max(
    ffi.Pointer<ffi.Void> array,
    ffi.Pointer<ffi.Int64> axis,
    int n_axis,
  ) {
    return _max(
      array,
      axis,
      n_axis,
    );
  }

  late final _maxPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int64>, ffi.Int)>>('max');
  late final _max = _maxPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int64>, int)>();

  ffi.Pointer<ffi.Void> nanmin(
    ffi.Pointer<ffi.Void> array,
    ffi.Pointer<ffi.Int64> axis,
    int n_axis,
  ) {
    return _nanmin(
      array,
      axis,
      n_axis,
    );
  }

  late final _nanminPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Int64>, ffi.Int)>>('nanmin');
  late final _nanmin = _nanminPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int64>, int)>();

  ffi.Pointer<ffi.Void> nanmax(
    ffi.Pointer<ffi.Void> array,
    ffi.Pointer<ffi.Int64> axis,
    int n_axis,
  ) {
    return _nanmax(
      array,
      axis,
      n_axis,
    );
  }

  late final _nanmaxPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Int64>, ffi.Int)>>('nanmax');
  late final _nanmax = _nanmaxPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int64>, int)>();

  ffi.Pointer<ffi.Void> normalize(
    ffi.Pointer<ffi.Void> array,
  ) {
    return _normalize(
      array,
    );
  }

  late final _normalizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('normalize');
  late final _normalize = _normalizePtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> rfft(
    ffi.Pointer<ffi.Void> array,
  ) {
    return _rfft(
      array,
    );
  }

  late final _rfftPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('rfft');
  late final _rfft = _rfftPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> rfft2(
    ffi.Pointer<ffi.Void> array,
  ) {
    return _rfft2(
      array,
    );
  }

  late final _rfft2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('rfft2');
  late final _rfft2 = _rfft2Ptr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> rfftfreq(
    int n,
    double d,
  ) {
    return _rfftfreq(
      n,
      d,
    );
  }

  late final _rfftfreqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Int64, ffi.Double)>>('rfftfreq');
  late final _rfftfreq =
      _rfftfreqPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, double)>();

  histogram_pointers histogram(
    ffi.Pointer<ffi.Void> array,
    int nbins,
  ) {
    return _histogram(
      array,
      nbins,
    );
  }

  late final _histogramPtr = _lookup<
      ffi.NativeFunction<
          histogram_pointers Function(
              ffi.Pointer<ffi.Void>, ffi.Int)>>('histogram');
  late final _histogram = _histogramPtr
      .asFunction<histogram_pointers Function(ffi.Pointer<ffi.Void>, int)>();

  void print_array(
    ffi.Pointer<ffi.Void> array,
  ) {
    return _print_array(
      array,
    );
  }

  late final _print_arrayPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'print_array');
  late final _print_array =
      _print_arrayPtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
}

final class slice extends ffi.Struct {
  @ffi.Int64()
  external int start;

  @ffi.Int64()
  external int stop;

  @ffi.Bool()
  external bool noRange;
}

final class histogram_pointers extends ffi.Struct {
  external ffi.Pointer<ffi.Void> count;

  external ffi.Pointer<ffi.Void> bin_edges;
}
